// Code generated by goa v2.0.0-wip, DO NOT EDIT.
//
// fleet HTTP client CLI support package
//
// Command:
// $ goa gen github.com/proepkes/speeddate/src/spawnsvc/design

package client

import (
	"encoding/json"
	"fmt"
	"strconv"

	fleet "github.com/proepkes/speeddate/src/spawnsvc/gen/fleet"
	goa "goa.design/goa"
)

// BuildCreatePayload builds the payload for the fleet create endpoint from CLI
// flags.
func BuildCreatePayload(fleetCreateBody string) (*fleet.Fleet, error) {
	var err error
	var body CreateRequestBody
	{
		err = json.Unmarshal([]byte(fleetCreateBody), &body)
		if err != nil {
			return nil, fmt.Errorf("invalid JSON for body, example of valid JSON:\n%s", "'{\n      \"FleetSpec\": {\n         \"Replicas\": 737777790,\n         \"Template\": {\n            \"GameServerSpec\": {\n               \"ContainerImage\": \"gcr.io/agones-images/udp-server:0.4\",\n               \"ContainerName\": \"my-server\",\n               \"ContainerPort\": 7777,\n               \"PortPolicy\": \"dynamic\"\n            },\n            \"ObjectMeta\": {\n               \"GenerateName\": \"my-server\",\n               \"Namespace\": \"speeddate-system\"\n            }\n         }\n      },\n      \"ObjectMeta\": {\n         \"GenerateName\": \"my-server\",\n         \"Namespace\": \"speeddate-system\"\n      }\n   }'")
		}
		if body.FleetSpec == nil {
			err = goa.MergeErrors(err, goa.MissingFieldError("FleetSpec", "body"))
		}
		if body.ObjectMeta != nil {
			if err2 := body.ObjectMeta.Validate(); err2 != nil {
				err = goa.MergeErrors(err, err2)
			}
		}
		if body.FleetSpec != nil {
			if err2 := body.FleetSpec.Validate(); err2 != nil {
				err = goa.MergeErrors(err, err2)
			}
		}
		if err != nil {
			return nil, err
		}
	}
	if err != nil {
		return nil, err
	}
	v := &fleet.Fleet{}
	if body.ObjectMeta != nil {
		v.ObjectMeta = marshalObjectMetaRequestBodyToObjectMeta(body.ObjectMeta)
	}
	if body.FleetSpec != nil {
		v.FleetSpec = marshalFleetSpecRequestBodyToFleetSpec(body.FleetSpec)
	}
	return v, nil
}

// BuildDeletePayload builds the payload for the fleet delete endpoint from CLI
// flags.
func BuildDeletePayload(fleetDeleteName string, fleetDeleteNamespace string) (*fleet.DeletePayload, error) {
	var name string
	{
		name = fleetDeleteName
	}
	var namespace string
	{
		if fleetDeleteNamespace != "" {
			namespace = fleetDeleteNamespace
		}
	}
	payload := &fleet.DeletePayload{
		Name:      name,
		Namespace: namespace,
	}
	return payload, nil
}

// BuildPatchPayload builds the payload for the fleet patch endpoint from CLI
// flags.
func BuildPatchPayload(fleetPatchNamespace string, fleetPatchName string, fleetPatchReplicas string) (*fleet.PatchPayload, error) {
	var err error
	var namespace string
	{
		if fleetPatchNamespace != "" {
			namespace = fleetPatchNamespace
		}
	}
	var name string
	{
		name = fleetPatchName
	}
	var replicas *uint32
	{
		if fleetPatchReplicas != "" {
			var v uint64
			v, err = strconv.ParseUint(fleetPatchReplicas, 10, 32)
			val := uint32(v)
			replicas = &val
			if err != nil {
				err = fmt.Errorf("invalid value for replicas, must be UINT32")
			}
		}
	}
	if err != nil {
		return nil, err
	}
	payload := &fleet.PatchPayload{
		Namespace: namespace,
		Name:      name,
		Replicas:  replicas,
	}
	return payload, nil
}

// BuildListPayload builds the payload for the fleet list endpoint from CLI
// flags.
func BuildListPayload(fleetListNamespace string, fleetListView string) (*fleet.ListPayload, error) {
	var namespace string
	{
		if fleetListNamespace != "" {
			namespace = fleetListNamespace
		}
	}
	var view *string
	{
		if fleetListView != "" {
			view = &fleetListView
		}
	}
	payload := &fleet.ListPayload{
		Namespace: namespace,
		View:      view,
	}
	return payload, nil
}

// BuildAllocatePayload builds the payload for the fleet allocate endpoint from
// CLI flags.
func BuildAllocatePayload(fleetAllocateNamespace string, fleetAllocateFleet2 string, fleetAllocateName string) (*fleet.AllocatePayload, error) {
	var namespace string
	{
		if fleetAllocateNamespace != "" {
			namespace = fleetAllocateNamespace
		}
	}
	var fleet2 string
	{
		fleet2 = fleetAllocateFleet2
	}
	var name string
	{
		name = fleetAllocateName
	}
	payload := &fleet.AllocatePayload{
		Namespace: namespace,
		Fleet:     fleet2,
		Name:      name,
	}
	return payload, nil
}

// BuildConfigurePayload builds the payload for the fleet configure endpoint
// from CLI flags.
func BuildConfigurePayload(fleetConfigureBody string) (*fleet.ConfigurePayload, error) {
	var err error
	var body ConfigureRequestBody
	{
		err = json.Unmarshal([]byte(fleetConfigureBody), &body)
		if err != nil {
			return nil, fmt.Errorf("invalid JSON for body, example of valid JSON:\n%s", "'{\n      \"ContainerImage\": \"Sit laudantium aut quod perferendis neque quis.\",\n      \"ContainerName\": \"Quisquam minima quidem dolore sint voluptatibus molestias.\",\n      \"ContainerPort\": 69570132,\n      \"GameserverNamePrefix\": \"Alias quas omnis qui harum ad.\",\n      \"NamePrefix\": \"Sunt enim.\",\n      \"Namespace\": \"Aut quia est a nam quia optio.\",\n      \"Replicas\": 1600223366\n   }'")
		}
	}
	if err != nil {
		return nil, err
	}
	v := &fleet.ConfigurePayload{
		NamePrefix:           body.NamePrefix,
		ContainerImage:       body.ContainerImage,
		ContainerName:        body.ContainerName,
		ContainerPort:        body.ContainerPort,
		GameserverNamePrefix: body.GameserverNamePrefix,
		Namespace:            body.Namespace,
		Replicas:             body.Replicas,
	}
	return v, nil
}
